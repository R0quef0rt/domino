<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- KLIPSE ASSETS -->
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
    <script>
        window.klipse_settings = {
            selector: '.lang-eval-clojure', // css selector for the html elements you want to klipsify
        };
    </script>
    <!-- END KLIPSE ASSETS -->

    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="highlight.pack.css">

  </head>
  <body>

    <h1>Domino</h1>
    <p>Domino is a data flow engine that helps you organize the interactions between your data model and events. Domino allows
    you to declare your business logic using a directed acyclic graph of events and effects. Whenever an external change is
    transacted to the data model, the graph determines the chain of events that will be executed, and side effects triggered
    as a result of the computation.</p>
    
    <p>A common problem applications tend to have a lot of ad hoc business logic. This negatively affects maintainability
    because it becomes difficult to reason about how one change affects another part of the program. This also makes it a
    challenge to refactor, change, or add to programs. Domino makes the interactions between pieces of business logic
    explicit and centralized.</p>
    
    <p>Domino explicitly separates logic that makes changes to the data model from side effectful functions. Business logic
    functions in Domino explicitly declare how they interact with the data model by declaring their inputs and outputs.
    Domino builds graphs of related events using these declarations. This approach handles cascading business logic out of
    the box, and provides a data specification for your business logic.</p>

    <h2>Usage</h2>
    <strong>1. Require <code>domino.core</code></strong>
    <pre><code class="lang-clojure">(require '[domino.core :as domino])</code></pre>
  
    <strong>2. Declare your schema</strong>
    <p>Let's take a look at a simple engine that accumulates a total. Whenever an amount is set, this value is added to the
    current value of the total. If the total exceeds 1337 at any point, it prints out a statement that says "Woah. That's a
    lot."</p>

    <pre><code class="lang-eval-clojure" data-external-libs="https://raw.githubusercontent.com/domino-clj/domino/master/src/" data-preamble="(require '[domino.core :as domino])">
      (def schema
        {:model   [[:amount {:id :amount}]
                    [:total {:id :total}]]
        :events  [{:inputs  [:amount]
                    :outputs [:total]
                    :handler (fn [ctx [amount] [total]]
                                [(+ total amount)])}]
        :effects [{:inputs [:total]
                    :handler (fn [ctx [total]]
                                (when (> total 1337)
                                (println "Woah. That's a lot.")))}]})
    </code></pre>

    <strong>3. Initialize the engine</strong>
    <p>You initialize the engine by calling the <code>domino/initialize!</code> function. This function is a one- or two-arity function,
    taking a schema and, optionally, an initial state map. In our example, we will give it our defined schema, and an
    initial value for <code>:total</code> as 0.</p>

    <pre><code class="lang-eval-clojure" data-external-libs="https://raw.githubusercontent.com/domino-clj/domino/master/src/">
      (def ctx (atom (domino/initialize! schema {:total 0})))
    </code></pre>
    
    <p><code>initialize!</code> will create the initial state of the engine (context). This will contain the model, events, effects, event
    graph, and db (state). In our example we use an atom in order to easily update the state of the engine.</p>

    <strong>4. Transact your external data changes</strong>
    <p>We can update the state of the data by calling the <code>domino/transact</code> function that accepts the current ctx and an inputs
    vector, and returns the updated context. The input vector is a collection of path-value pairs. For example, to set the
    value of <code>:amount</code> to 10, you would pass in the following input vector <code>[[[:amount] 10]]</code>.</p>

    <pre><code class="lang-eval-clojure" data-external-libs="https://raw.githubusercontent.com/domino-clj/domino/master/src/">
      (swap! ctx domino/transact [[[:amount] 10]])
    </code></pre>

    <p>The updated context contains the <code>:change-history</code> which is a simple vector of all the changes as they were applied to the
    data (in sequence).</p>

    <pre><code class="lang-eval-clojure" data-external-libs="https://raw.githubusercontent.com/domino-clj/domino/master/src/">
      (:change-history @ctx)
    </code></pre>

    <p>We can see the new context contains the updated total amount and the change history shows the order in which the changes
    were applied.</p>
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
  </body>
</html>